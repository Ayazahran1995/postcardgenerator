<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Postcard Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 9999px; /* Tailwind's rounded-full */
            border: none;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-sky-100 text-gray-800 font-inter">

    <h1 class="mb-8 text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-purple-600 drop-shadow-xl">
        Postcard Creator
    </h1>

    <div class="flex flex-col items-center w-full max-w-4xl p-8 bg-white rounded-2xl shadow-3xl">

        <!-- Gemini API Control Panel -->
        <div class="w-full mb-6 text-center">
            <h2 class="text-xl font-semibold mb-2 text-gray-700">✨ Generate a Custom Background</h2>
            <div class="flex flex-col md:flex-row gap-2">
                <input
                    type="text"
                    id="promptInput"
                    placeholder="e.g., A happy dog on a beach at sunset"
                    class="flex-grow p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <button
                    id="generateBtn"
                    class="px-6 py-2 font-semibold text-white bg-green-500 rounded-lg shadow-lg hover:bg-green-600 transition-all duration-200"
                >
                    ✨ Generate Background
                </button>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="flex flex-wrap items-center justify-center w-full p-4 mb-6 space-y-4 rounded-xl md:space-y-0 md:space-x-4 bg-blue-100">
            <div class="flex items-center space-x-2">
                <label for="brushSize" class="text-gray-600">Size:</label>
                <input
                    type="range"
                    id="brushSize"
                    min="1"
                    max="50"
                    value="5"
                    class="w-24 h-2 rounded-lg appearance-none cursor-pointer bg-blue-200"
                />
            </div>
            
            <div class="flex items-center space-x-2">
                <label class="text-gray-600">Style:</label>
                <div id="styleButtons" class="flex flex-wrap justify-center gap-2">
                    <button id="standardBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-blue-600 ring-2 ring-blue-500 transform scale-110">
                        Standard
                    </button>
                    <button id="impressionistBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-orange-500">
                        Impressionist
                    </button>
                    <button id="pointillistBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-teal-500">
                        Pointillist
                    </button>
                    <button id="expressionistBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-purple-500">
                        Expressionist
                    </button>
                </div>
            </div>

            <div class="flex items-center space-x-2">
                <label class="text-gray-600">Color:</label>
                <div id="colorPalette" class="flex space-x-1">
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-blue-400 scale-110" style="background-color: #2563eb;"></button>
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-transparent" style="background-color: #ef4444;"></button>
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-transparent" style="background-color: #10b981;"></button>
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-transparent" style="background-color: #fcd34d;"></button>
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-transparent" style="background-color: #f97316;"></button>
                    <button class="w-8 h-8 rounded-full border-2 transition-transform duration-100 shadow-md border-transparent" style="background-color: #a855f7;"></button>
                </div>
                <input
                    type="color"
                    id="brushColor"
                    value="#2563eb"
                    class="w-10 h-10 rounded-full cursor-pointer bg-transparent border-none"
                />
            </div>
        </div>

        <!-- Main Canvas and Buttons -->
        <div class="relative w-full overflow-hidden rounded-xl shadow-inner aspect-[4/3] max-w-[800px] max-h-[600px] bg-white border border-gray-300">
            <canvas id="drawingCanvas" class="w-full h-full"></canvas>
            <div id="loadingOverlay" class="absolute inset-0 flex flex-col items-center justify-center p-4 text-center text-white bg-gray-900 bg-opacity-70 hidden">
                <svg class="animate-spin h-10 w-10 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-4 text-lg">Generating your masterpiece...</p>
            </div>
            <div id="instructions" class="absolute inset-0 flex items-center justify-center p-4 text-center text-gray-500 bg-white bg-opacity-70">
                <p class="text-lg">Click or tap to start drawing your postcard!</p>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-wrap justify-center gap-4 p-4 mt-6">
            <button id="eraserBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-red-600">
                Eraser
            </button>
            <button id="clearBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-blue-500 hover:bg-blue-600">
                Clear
            </button>
            <button id="downloadBtn" class="px-4 py-2 font-semibold text-white transition-all duration-200 rounded-lg shadow-lg hover:scale-105 active:scale-95 bg-teal-500 hover:bg-teal-600">
                Download Postcard
            </button>
        </div>
    </div>

    <script>
        // --- Canvas Setup and State Management ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const instructions = document.getElementById('instructions');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let isDrawing = false;
        let brushColor = '#2563eb';
        let brushSize = 5;
        let brushStyle = 'standard';
        const canvasBackground = '#ffffff';
        let generatedBackgroundImage = null;

        // Set up the canvas dimensions and initial background
        const resizeCanvas = () => {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            canvas.width = Math.min(window.innerWidth * 0.9, 800);
            canvas.height = Math.min(window.innerHeight * 0.7, 600);
            
            // Redraw background if it exists
            if (generatedBackgroundImage) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = oldWidth;
                tempCanvas.height = oldHeight;
                tempCtx.drawImage(generatedBackgroundImage, 0, 0, oldWidth, oldHeight);
                ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = canvasBackground;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // --- Helper function to get coordinates relative to the canvas ---
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                offsetX: clientX - rect.left,
                offsetY: clientY - rect.top
            };
        }

        // --- Drawing Logic ---
        function startDrawing(e) {
            const { offsetX, offsetY } = getCoords(e);
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            isDrawing = true;
            instructions.style.display = 'none';
        }

        function draw(e) {
            if (!isDrawing) return;

            const { offsetX, offsetY } = getCoords(e);

            switch (brushStyle) {
                case 'standard':
                    ctx.lineWidth = brushSize;
                    ctx.strokeStyle = brushColor;
                    ctx.lineTo(offsetX, offsetY);
                    ctx.stroke();
                    break;
                case 'impressionist':
                    ctx.lineWidth = brushSize * 2;
                    ctx.strokeStyle = brushColor;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(offsetX + (Math.random() * 5), offsetY + (Math.random() * 5));
                    ctx.lineTo(offsetX, offsetY);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'pointillist':
                    ctx.beginPath();
                    ctx.fillStyle = brushColor;
                    ctx.arc(offsetX, offsetY, brushSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'expressionist':
                    ctx.lineWidth = brushSize * 1.5;
                    ctx.strokeStyle = brushColor;
                    ctx.lineTo(offsetX + (Math.random() * 2), offsetY + (Math.random() * 2));
                    ctx.stroke();
                    break;
                case 'eraser':
                    ctx.lineWidth = brushSize * 2;
                    ctx.strokeStyle = canvasBackground;
                    ctx.lineTo(offsetX, offsetY);
                    ctx.stroke();
                    break;
                default:
                    break;
            }
        }

        function stopDrawing() {
            ctx.closePath();
            isDrawing = false;
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        // Handle touch events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling on mobile
            draw(e);
        }, { passive: false });

        // --- Gemini API Image Generation Logic ---
        const promptInput = document.getElementById('promptInput');
        const generateBtn = document.getElementById('generateBtn');
        const apiKey = ""; // Canvas will provide this automatically

        generateBtn.addEventListener('click', async () => {
            const userPrompt = promptInput.value.trim();
            if (!userPrompt) {
                alert("Please enter a prompt to generate an image.");
                return;
            }

            loadingOverlay.style.display = 'flex';
            instructions.style.display = 'none';
            generateBtn.disabled = true;

            const payload = { instances: { prompt: userPrompt }, parameters: { "sampleCount": 1} };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                const base64Data = result?.predictions?.[0]?.bytesBase64Encoded;

                if (base64Data) {
                    const image = new Image();
                    image.onload = () => {
                        // Clear the canvas and draw the new image as the background
                        ctx.fillStyle = canvasBackground;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                        generatedBackgroundImage = image;
                        loadingOverlay.style.display = 'none';
                        generateBtn.disabled = false;
                    };
                    image.src = `data:image/png;base64,${base64Data}`;
                } else {
                    throw new Error("No image data received.");
                }
            } catch (error) {
                console.error("Error generating image:", error);
                alert("Failed to generate image. Please try again.");
                loadingOverlay.style.display = 'none';
                generateBtn.disabled = false;
                instructions.style.display = 'flex';
            }
        });

        // --- UI Event Listeners ---
        const brushSizeInput = document.getElementById('brushSize');
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = e.target.value;
        });

        const colorPicker = document.getElementById('brushColor');
        colorPicker.addEventListener('input', (e) => {
            brushColor = e.target.value;
            // Update the selected color in the palette
            const paletteButtons = document.querySelectorAll('#colorPalette button');
            paletteButtons.forEach(btn => {
                const hexColor = rgbToHex(btn.style.backgroundColor);
                if (hexColor === brushColor) {
                    btn.classList.add('border-blue-400', 'scale-110');
                    btn.classList.remove('border-transparent');
                } else {
                    btn.classList.remove('border-blue-400', 'scale-110');
                    btn.classList.add('border-transparent');
                }
            });
        });

        const colorPalette = document.getElementById('colorPalette');
        colorPalette.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                brushColor = rgbToHex(e.target.style.backgroundColor);
                colorPicker.value = brushColor;
                const paletteButtons = document.querySelectorAll('#colorPalette button');
                paletteButtons.forEach(btn => btn.classList.remove('border-blue-400', 'scale-110'));
                e.target.classList.add('border-blue-400', 'scale-110');
                e.target.classList.remove('border-transparent');
            }
        });
        
        function rgbToHex(rgb) {
            if (!rgb || rgb.startsWith('#')) return rgb;
            const parts = rgb.match(/(\d+)/g);
            if (!parts) return '#000000';
            const r = parseInt(parts[0]).toString(16).padStart(2, '0');
            const g = parseInt(parts[1]).toString(16).padStart(2, '0');
            const b = parseInt(parts[2]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        const styleButtons = document.getElementById('styleButtons');
        styleButtons.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                // Remove active style from all buttons
                const buttons = styleButtons.querySelectorAll('button');
                buttons.forEach(btn => btn.classList.remove('ring-2', 'ring-blue-500', 'transform', 'scale-110'));
                // Add active style to the clicked button
                e.target.classList.add('ring-2', 'ring-blue-500', 'transform', 'scale-110');
                brushStyle = e.target.id.replace('Btn', '');
            }
        });

        document.getElementById('eraserBtn').addEventListener('click', () => {
            brushStyle = 'eraser';
            const buttons = styleButtons.querySelectorAll('button');
            buttons.forEach(btn => btn.classList.remove('ring-2', 'ring-blue-500', 'transform', 'scale-110'));
            document.getElementById('eraserBtn').classList.add('ring-2', 'ring-blue-500', 'transform', 'scale-110');
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            ctx.fillStyle = canvasBackground;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            instructions.style.display = 'flex';
            generatedBackgroundImage = null;
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const image = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = image;
            link.download = 'my-postcard.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    </script>

</body>
</html>
    </script>

</body>
</html>
